<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Walrus</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Walrus</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Overview</li><li class="chapter-item expanded "><a href="objectives_use_cases.html"><strong aria-hidden="true">1.</strong> Objectives and use-cases</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="properties.html"><strong aria-hidden="true">2.1.</strong> Properties</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.2.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="encoding.html"><strong aria-hidden="true">2.3.</strong> Encoding</a></li></ol></li><li class="chapter-item expanded "><a href="operations.html"><strong aria-hidden="true">3.</strong> Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="operations-sui.html"><strong aria-hidden="true">3.1.</strong> Sui operations</a></li><li class="chapter-item expanded "><a href="operations-off-chain.html"><strong aria-hidden="true">3.2.</strong> Off-chain operations</a></li></ol></li><li class="chapter-item expanded "><a href="future.html"><strong aria-hidden="true">4.</strong> Future discussion</a></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Setup</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Prerequisites</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Installation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Configuration</div></li></ol></li><li class="chapter-item expanded "><a href="interacting.html"><strong aria-hidden="true">6.</strong> Interacting with Walrus</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="client-cli.html"><strong aria-hidden="true">6.1.</strong> Using the client CLI</a></li><li class="chapter-item expanded "><a href="json-api.html"><strong aria-hidden="true">6.2.</strong> Using the client JSON API</a></li><li class="chapter-item expanded "><a href="web-api.html"><strong aria-hidden="true">6.3.</strong> Using the client HTTP API</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Examples</div></li><li class="chapter-item expanded affix "><li class="part-title">Walrus sites</li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="glossary.html">Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Walrus</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="walrus"><a class="header" href="#walrus">Walrus</a></h1>
<p>Welcome to the developer documentation for Walrus, a decentralized storage and availability protocol
designed specifically for large binary files, or "blobs". Walrus focuses on providing a robust
solution for storing unstructured content on decentralized storage nodes while ensuring high
availability and reliability even in the presence of Byzantine faults.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>
<p><strong>Storage and retrieval</strong>: Walrus supports storage operations to write and read blobs. It also
allows anyone to prove that a blob has been stored and is available for retrieval at a later
time.</p>
</li>
<li>
<p><strong>Cost efficiency</strong>: By utilizing advanced error correction coding, Walrus maintains storage
costs at approximately five times the size of the stored blobs and encoded parts of each blob
are stored on each storage node. This is significantly more cost-effective compared to
traditional full replication methods and much more robust against failures compared to
protocols that only store each blob on a subset of storage nodes.</p>
</li>
<li>
<p><strong>Integration with Sui blockchain</strong>: Walrus leverages the <a href="https://github.com/MystenLabs/sui">Sui</a>
for coordination, attesting availability and payments. Storage space can be owned as a resource on
Sui, split, merged, and transferred. Blob storage is represented using storage objects on Sui, and
smart contracts can check whether a blob is available and for how long.</p>
</li>
<li>
<p><strong>Flexible access</strong>: Users can interact with Walrus through a command-line interface (CLI),
software development kits (SDKs), and web2 HTTP technologies. Walrus is designed to work well
with traditional caches and content distribution networks (CDNs), while ensuring all operations
can also be run using local tools to maximize decentralization.</p>
</li>
</ul>
<h2 id="architecture-and-operations"><a class="header" href="#architecture-and-operations">Architecture and operations</a></h2>
<p>Walrus's architecture ensures that content remains accessible and retrievable even when many
storage nodes are unavailable or malicious. Under the hood it uses modern error correction
techniques based on fast linear fountain codes, augmented to ensure resilience against Byzantine
faults, and a dynamically changing set of storage nodes. The core of Walrus remains simple, and
storage node management and blob certification leverages Sui smart contracts.</p>
<p>This documentation is split into several parts. The first part provides an overview of the
objectives, security properties, and architecture of the Walrus system. The second part contains
concrete documentation on the usage of Walrus. At the end, we provide a <a href="./glossary.html">glossary</a>,
which defines key terms used throughout the project.</p>
<p>Walrus is architected to provide a reliable and cost-effective solution for large-scale blob
storage, making it an ideal choice for applications requiring decentralized, affordable, durable,
and accessible data storage.</p>
<h2 id="sources"><a class="header" href="#sources">Sources</a></h2>
<p>This documentation is built using <a href="https://rust-lang.github.io/mdBook/">mdBook</a> from source files in
<a href="https://github.com/MystenLabs/walrus-docs/">github.com/MystenLabs/walrus-docs/</a>. Please report or
fix any errors you find in this documentation in that GitHub project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objectives-and-use-cases"><a class="header" href="#objectives-and-use-cases">Objectives and use-cases</a></h1>
<p>Walrus supports operations to store and retrieve blobs, and to prove and verify their availability.
It ensures content survives storage nodes suffering Byzantine faults and remains available and
retrievable. It provides APIs to access the stored content over a CLI, SDKs and over web2 HTTP
technologies, and supports contend delivery infrastructures like caches and content distribution
networks (CDNs).</p>
<p>Under the hood, storage cost is a small fixed multiple of the size of blobs (around 5x) thanks to
advanced error correction coding, in contrast to the full replication of data traditional to
blockchains such as &gt;100x for data stored in Sui objects. As a result much bigger resources, up to
several GiB, may be stored on Walrus at substantially lower cost compared to Sui or other
blockchains. Since encoded blobs are stored on all storage nodes Walrus also provides superior
robustness compared with designs with a small amount of replicas storing the full blob.</p>
<p>Walrus uses the Sui chain for coordination and payments. Available storage is represented as Sui
objects that can be acquired, owned, split, merged and transferred. Storage space can be tied to
a stored blob for a period of time. And the resulting Sui object may be used to prove
availability on chain in smart contracts, or off chain using light clients.</p>
<p>In the <a href="./overview.html">next chapter</a> we discuss in details the above operations relating to storage,
retrieval and availability.</p>
<p>In the future, we plan to include in Walrus some minimal governance to allow storage nodes to
change between storage epochs. Walrus is also compatible with periodic payments for continued
storage. We also plan to implement storage attestation based on challenges to get confidence that
that blobs are stored or at least available. Walrus also allows light-nodes that store small parts
of blobs to get rewards for proving availability and assisting recovery. We will cover these
topics in later documents. We also provide details of the encoding scheme in a separate document.</p>
<h2 id="non-objectives"><a class="header" href="#non-objectives">Non-objectives</a></h2>
<p>There are a few things that Walrus explicitly is not:</p>
<ul>
<li>Walrus does not reimplement a CDN that might be geo-replicated or have less than tens of
milliseconds of latency. Instead, it ensures that traditional CDNs are usable and compatible with
Walrus caches.</li>
<li>Walrus does not re-implement a full smart contracts platform with consensus or execution. It
relies on Sui smart contracts when necessary, to manage Walrus resources and processes including
payments, storage epochs etc.</li>
<li>Walrus supports storage of any blob including encrypted blobs, however Walrus itself is not the
distributed key management infrastructure that manages and distributed encryption or decryption
keys to support a full private storage eco-system. It can however provide the storage layer of for
such infrastructures.</li>
</ul>
<h2 id="use-cases"><a class="header" href="#use-cases">Use-cases</a></h2>
<p>App builders may use Walrus in conjunction with Sui to build experiences that require large
amounts of  data to be stored in a decentralized manner and possibly certified as available:</p>
<ul>
<li><strong>Storage of media for NFT or dapps</strong>: Walrus can directly store and serve media such as images,
sounds, sprites, videos, other game assets, etc. This is publicly available media that can be
accessed using HTTP requests at caches to create multimedia dapps.</li>
<li><strong>AI related use cases</strong>: Walrus can store clean data sets of training data, datasets with a
known and verified provenance, models weights, and proofs of correct training for AI models.
Or it may be used to store and ensure the availability of an AI model output.</li>
<li><strong>Storage of long term archival of blockchain history</strong>: Walrus can be used as a lower cost
decentralized store to store blockchain history. For Sui this can include sequences of
checkpoints with all associated transaction and effects content. As well as historic snapshots
of the blockchain state, code or binaries.</li>
<li><strong>Support availability for L2s</strong>: Walrus allows parties to certify the availability of blobs, as
required by L2s that need data to be stored and be attested as available to all. This may also
include availability of extra audit data such as validity proofs, zero knowledge proofs of
correct execution or large fraud proofs.</li>
<li><strong>Support a full decentralized web experience</strong>: Walrus can host full decentralized web
experiences including all resources (such as js, css, html, media). These can provide content but
also host the UX of dapps to build dapps with fully decentralized front end and back ends on
chain. It brings the full "web" back in "web3".</li>
<li><strong>Support subscription models for media</strong>: Creators can store encrypted media on Walrus and only
provide access via decryption keys to parties that have paid a subscription fee or have paid for
contents. (Note that Walrus provides the storage, encryption and decryption needs to happen off
Walrus).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-overview"><a class="header" href="#system-overview">System overview</a></h1>
<p>This chapter provides an overview of the <a href="./properties.html">security properties</a>,
<a href="./architecture.html">architecture</a>, and <a href="./encoding.html">encoding mechanisms</a> of the Walrus system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="walrus-assurance-and-security-properties"><a class="header" href="#walrus-assurance-and-security-properties">Walrus assurance and security properties</a></h1>
<p>The properties below hold true subject to the assumption that for all storage epochs 2/3 of shards
are operated by storage nodes that faithfully and correctly follow the Walrus protocol.</p>
<p>Each blob is encoded using error correction into slivers and a <strong>blob ID</strong> is cryptographically
derived. For a given blob ID there is a <strong>point of availability</strong> (PoA) and an <strong>availability
period</strong>, observable through an event on the Sui chain. The following properties relate to the PoA:</p>
<ul>
<li>After the PoA, for a blob ID, any correct user that performs a read within the availability
period will eventually terminate and get a value V which is either blob contents F or None.</li>
<li>After PoA if two correct users perform a read and get V and V’ then V = V’.</li>
<li>A correct user with an appropriate storage resource can always perform store for a blob F with a
blob ID and advance the protocol until the PoA.</li>
<li>A read after PoA for a blob F stored by a correct user, will result in F.</li>
</ul>
<p>Some assurance properties ensure the correct internal processes of Walrus storage nodes.
For the purposes of defining these, an <strong>inconsistency proof</strong> proves that a blob ID was
stored by an incorrect user (and was incorrectly encoded).</p>
<ul>
<li>After PoA and for a blob ID stored by a correct user, a storage node is always able to recover
the correct sliver for its shards for this blob ID.</li>
<li>After PoA if a correct storage node cannot recover a sliver, it can produce an inconsistency proof
for the blob ID.</li>
<li>If a blob ID is stored by a correct user, an inconsistently proof cannot be derived for it.</li>
<li>A read by a correct user for a blob ID for which an inconsistency proof may exist returns None.</li>
</ul>
<p>Note that there is no delete operation and a blob ID past PoA will be available for the full
availability period.</p>
<p>As a rule of thumb: before PoA it is the responsibility of a client to ensure the availability of
a blob and its upload to Walrus. After PoA it is the responsibility of Walrus as a system to
maintain the availability of the blob ID as part of its operation for the full availability period
remaining. Emission of the event corresponding to the PoA for a blob ID attests its
availability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-architecture-and-security-assumptions"><a class="header" href="#basic-architecture-and-security-assumptions">Basic architecture and security assumptions</a></h1>
<p>The key actors in the Walrus architecture are the following:</p>
<ul>
<li><strong>Users</strong> through <strong>clients</strong> want to store and read <strong>blobs</strong>. They are ready to pay for service
when it comes to writes, and when it comes to non-best-effort reads. Users also want to prove
the <strong>availability</strong> of a blob to third parties without the cost of sending or receiving the full
blob. Users may be malicious in various ways: they may wish to not pay for services, prove the
availability of an unavailable blobs, or modify / delete blobs without authorization, try to
exhaust resources of storage nodes, etc.</li>
<li><strong>Storage nodes</strong> hold one or many <strong>shards</strong> within a <strong>storage epoch</strong>. Each blob is erasure
encoded in many <strong>slivers</strong> and slivers from each stored blob become part of all shards. A shard
at any storage epoch is associated with a <strong>storage node</strong> that actually stores all slivers of
the shard, and is ready to serve them. The assignment of storage nodes to shards within
<strong>storage epochs</strong> is controlled by a Sui smart contract and we assume that more than 2/3 of the
shards are managed by correct storage nodes within each storage epoch. This means that we must
tolerate up to 1/3 Byzantine storage nodes within each storage epoch and across storage epochs.</li>
<li>All clients and storage nodes operate a <strong>blockchain</strong> client (specifically on Sui), and mediate
payments, resources (space), mapping of shards to storage nodes, and metadata through blockchain
smart contracts. Users interact with the blockchain to get storage resources and certify stored
blobs, and storage nodes listen to the blockchain events to coordinate their operations.</li>
</ul>
<p>Walrus supports any additional number of optional infrastructure actors that can operate in a
permissionless way:</p>
<ul>
<li><strong>Caches</strong> are <strong>clients</strong> that store one or more full blobs and make them available to users
over traditional web2 (HTTP, etc) technologies. They are optional in that end-users may also
operate a local cache, and perform Walrus reads over web2 technologies locally. However, cache
infrastructures may also act as CDNs, share the cost of blob reconstruction over many requests,
have better connectivity, etc. A client can always verify that reads from such infrastructures
are correct.</li>
<li><strong>Publishers</strong> are <strong>clients</strong> that help end-users store a blob using web2 technologies, and
using less bandwidth and custom logic. They in effect receive the blob to be published. over
traditional web2 protocols (e.g., HTTP), and perform the Walrus store protocol on their behalf,
including the encoding, distribution of slivers to shards, creation of certificate of certificate,
and other on-chain actions. They are optional in that a user may directly interact with both Sui
and storage nodes to store blobs directly. An end user can always verify that a publisher
performed their duties correctly by attesting availability.</li>
</ul>
<p>Caches, publishers, and end-users are not considered trusted components of the system, and they may
deviate from the protocol arbitrarily. However, some of the security properties of Walrus only hold
for honest end-users that use honest intermediaries (caches and publishers). We provide means for
end-users to audit the correct operation of both caches and publishers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encoding-overheads-and-verification"><a class="header" href="#encoding-overheads-and-verification">Encoding, overheads, and verification</a></h1>
<p>We summarize here the basic encoding and cryptographic techniques used in Walrus.</p>
<ul>
<li><strong>Storage nodes</strong> hold one or many <strong>shards</strong> in a storage epoch, out of a larger total (say 1000)
and each shard contains one blob <strong>sliver</strong> for each blob past PoA. Each shard is assigned to a
storage node in a storage epoch.</li>
<li>An <a href="https://en.wikipedia.org/wiki/Online_codes">erasure code</a> <strong>encode algorithm</strong> takes a blob,
and encodes it as $K$ symbols, such that any fraction $p$ of symbols can be used to reconstruct
the blob. Each blob sliver contains a fixed number of such symbols.</li>
<li>We select $p&lt;1/3$ so that a third of symbols and also slivers may be used to reconstruct the blob
by the <strong>decode algorithm</strong>. The matrix used to produce the erasure code is fixed and the same
for all blobs by the Walrus system, and encoders have no discretion about it.</li>
<li>Storage nodes manage one or more shards, and corresponding sliver of each blob are distributed
to all the storage shards. As a result, the overhead of the distributed store is ~5x that of
the blob itself, no matter how many shards we have. The encoding is systematic meaning that some
storage nodes hold part of the plain blob, allowing for fast random access reads.</li>
</ul>
<p>Each blob is also associated with some metadata including a blob ID to allow verification:</p>
<ul>
<li>A blob ID is computed as an authenticator of the set of all shard data and metadata (byte size,
encoding, blob hash). We hash a sliver representation in each of the shards and add the resulting
hashes into a Merkle tree. Then the root of the Merkle tree is the blob hash used to derive the
blob ID that identifies the blob in the system.</li>
<li>Each storage node may use the blob ID to check if some shard data belongs to a blob using the
authenticated structure corresponding to the blob hash (Merkle tree). A successful check means
that the data is indeed as intended by the writer of the blob (who, remember, may be corrupt).</li>
<li>When any party reconstructs a blob ID from shards data and slivers, or accepts any blob purporting
to be a specific blob ID, it must check that it encodes to the correct blob ID. This process
involves re-coding the blob using the erasure correction code, and re-deriving the blob ID to
check the blob indeed matches it. This prevents a malformed blob (i.e., incorrectly erasure coded)
from ever being read with a blob ID at any correct recipient.</li>
<li>A set of slivers above the reconstruction threshold belonging to a blob ID that are either
inconsistent or lead to the reconstruction of a different ID represent an incorrect encoding
(this may happen if the user that encoded the blob was malicious and encoded it incorrectly).
Storage nodes may delete slivers belonging to inconsistently encoded blobs, and upon request
return an inconsistency proof.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operations"><a class="header" href="#operations">Operations</a></h1>
<p>Walrus operations can be separated in <a href="./operations-sui.html">interactions with the Sui chain</a>, which
is used by Walrus for coordination and governance, and <a href="./operations-off-chain.html">off-chain
interactions</a> between clients and storage nodes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operations-on-sui"><a class="header" href="#operations-on-sui">Operations on Sui</a></h1>
<p>Walrus uses Sui smart contracts to coordinate storage operations as resources that have a lifetime,
and payments. As well as to facilitate governance to determine the storage nodes holding each
storage shard. We outline here these operations and refer to them below as part of the read / write
paths. As a reminder, only blob metadata is ever exposed to Sui or its validators, and the content
of blobs is always stored off-chain on Walrus storage nodes and caches. The storage nodes or caches
do not have to overlap with any Sui infra (validators etc), and the storage epochs may be of
different lengths and not have the same start / end times as Sui epochs.</p>
<h2 id="storage-resource-life-cycle-on-sui"><a class="header" href="#storage-resource-life-cycle-on-sui">Storage resource life cycle on Sui</a></h2>
<p>A number of Sui smart contracts hold the metadata of the Walrus system and all its entities.</p>
<ul>
<li>A <strong>Walrus system object</strong> holds the committee of storage nodes for the current storage epoch. The
system object also holds the total available space on Walrus and the price per unit of storage (1
KiB). These values are determined by 2/3 agreement between the storage nodes for the storage
epoch. Users can pay to purchase storage space for some time duration. These space resources may
be split, merged and transferred. Later they can be used to place a blob ID into Walrus.</li>
<li>The <strong>storage fund</strong> holds funds for storing blobs over one, multiple storage epochs or
perpetually. When purchasing storage space from the system object users pay into the storage fund
separated over multiple storage epochs, and payments are made each epoch to storage nodes
according to performance (see below).</li>
<li>A user acquires some storage through the contracts or transfer, and can assign to it a blob ID,
signifying they wish to store this blob ID into it. This emits a Move <strong>resource event</strong> that
both caches and storage nodes listen to to expect and authorize off-chain storage operations.</li>
<li>Eventually a user holds an off-chain <strong>availability certificate</strong> from storage nodes for a blob
ID. The user <strong>uploads the certificate on chain</strong> to signal that the blob ID is available for an
availability period. The certificate is checked against the latest Walrus committee,
and an <strong>availability event</strong> is emitted for the blob ID if correct. This is the PoA for the
blob.</li>
<li>In case a blob ID is not correctly encoded a <strong>inconsistency proof certificate</strong> may be uploaded
on chain at a later time, and an <strong>inconsistent blob event</strong> is emitted signaling to all that the
blob ID read results will always return None. This indicates that its slivers may be deleted by
storage nodes, except for an indicator to return None.</li>
</ul>
<p>Users writing to Walrus, need to perform Sui transactions to acquire storage and certify blobs.
Users creating or consuming proofs for attestations of blob availability read the chain
only to prove or verify emission of events. A node that reads Walrus resources only needs to read
the blockchain to get committee metadata once per epoch, and then they request slivers directly
from storage nodes by blob ID to perform reads.</p>
<h2 id="governance-operations-on-sui"><a class="header" href="#governance-operations-on-sui">Governance operations on Sui</a></h2>
<p>Each Walrus storage epoch is represented by the Walrus system object that contains a storage
committee and various metadata or storage nodes like the mapping between shards and storage nodes,
available space and current costs. User may go to the system object for the period and <strong>buy some
storage</strong> amount for one or more storage epochs. At each storage epoch there is a price for storage,
and the payment provided becomes part of a <strong>storage fund</strong> for all the storage epochs that span
the storage bought. There is a maximum number of storage epochs in the future for which storage can
be bought (~2 years). Storage is a resource that can be split and merged, and transferred.</p>
<p>At the end of the storage epoch part of the funds in the <strong>storage fund need to be allocated to
storage nodes</strong>. The idea here is for storage nodes to perform light audits of each others,
and suggest which nodes are to be paid based on the performance of these audits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="off-chain-operations"><a class="header" href="#off-chain-operations">Off-chain operations</a></h1>
<p>Walrus operations happen off Sui, but may interact with the Sui flows defining the resource life
cycle.</p>
<h2 id="write-paths"><a class="header" href="#write-paths">Write paths</a></h2>
<p><img src="assets/WriteFlow.png" alt="Write paths of Walrus" /></p>
<p>Systems overview of writes, illustrated above:</p>
<ul>
<li>A user acquires a storage resource of appropriate size and duration on-chain, either by directly
buying it on the Walrus system object, or a secondary market. A user can split, merge, and
transfer storage acquired storage resources.</li>
<li>When a user wants to write a blob, it first erasure codes it using encode, and computes its
blob ID. Then they can perform the following steps itself, or use a publisher to perform steps
on their behalf.</li>
<li>The user goes on chain (Sui) and updates a storage resource to register the blob ID with the
appropriate size and lifetime desired. This emits an event, received by storage nodes. Once the
user receives it then continues the upload.</li>
<li>The user sends each of the blob slivers and metadata to the storage nodes that currently
manages the corresponding shards.</li>
<li>A storage node managing a shard receives a sliver and checks it against the blob ID of the overall
blob. It also checks that there is a blob resource with that blob ID that is authorized to store
a blob. If correct, then it signs a statement that it holds the sliver for blob ID (and metadata)
and returns it to the user.</li>
<li>The user puts together the signatures returned from storage nodes into an availability certificate
and sends it on chain. When successfully checked an availability event for the blob ID is emitted,
and all other storage nodes seek to download any missing shards for the blob ID. This event being
emitted on Sui is the Point of Availability (PoA) for the blob ID.</li>
<li>After the PoA, and without user involvement, storage nodes sync and recover any missing slivers
that are certified.</li>
</ul>
<p>The user waits for 2/3 of shards signatures to return a certificate of availability. The rate of the
code is below 1/3 allowing for reconstruction if even 1/3 of shards only return the sliver. Since at
most 1/3 of the storage nodes can fail, this ensures reconstruction if a reader requests slivers
from all storage nodes that have signed the ID of the blob. Note that the full process can be
mediated by a publisher, that receives a blob and drives the process to completion.</p>
<h2 id="refresh-availability"><a class="header" href="#refresh-availability">Refresh availability</a></h2>
<p>Since no content data is required to refresh the period of storage, refresh is conducted fully on
chain within the protocol. To request an extension to the availability period of a blob, a user
provides an appropriate storage resource. Upon success this emits an event that storage nodes
receive to extend the period each sliver is stored for.</p>
<h2 id="inconsistent-resource-flow"><a class="header" href="#inconsistent-resource-flow">Inconsistent resource flow</a></h2>
<p>When a correct storage node tries to reconstruct a shard it may fail if the encoding of a blob ID
past PoA was incorrect, and will be able to extract an inconsistency proof for the blob ID. It then
generates a inconsistency certificate and uploads it on chain. The flow is as follows:</p>
<ul>
<li>A storage node fails to reconstruct a shard, and generates an inconsistency proof.</li>
<li>The storage node sends the blob ID and inconsistency proof to all storage nodes of the storage
epoch, and gets a signature, that it aggregates to an inconsistency certificate.</li>
<li>The storage node sends the inconsistency certificate to the Walrus smart contract, that checks it
and emits a inconsistent resource event.</li>
<li>Upon receiving a inconsistent resource event correct storage nodes delete sliver data and only
keep a metadata record to return None for the blob ID for the availability period. No storage
attestation challenges are issued for this blob ID.</li>
</ul>
<p>Note that a blob ID that is inconsistent will always resolve to None upon reading: this is due to
the read process running the decoding algorithm, and then re-encoding to check the blob ID is
correctly derived from a consistent encoding. This means that an inconsistency proof only reveals a
true fact to storage nodes (that may not otherwise have ran decoding), and does not change the
output of read in any case.</p>
<p>Note however that partial reads leveraging the systematic nature of the encoding may return partial
reads for inconsistently encoded files. Thus if consistency and availability of reads is important
dapps should do full reads rather than partial reads.</p>
<h2 id="read-paths"><a class="header" href="#read-paths">Read paths</a></h2>
<p>A user can read stored blobs either directly or through a cache. We discuss here the direct user
journey since this is also the operation of the cache in case of a cache miss. We assume that most
reads will happen through caches, for blobs that are hot, and will not result in requests to
storage nodes.</p>
<ul>
<li>The reader gets the metadata for the blob ID from any storage node, and authenticates it using
the blob ID.</li>
<li>The reader then sends a request for the shards corresponding to blob ID to storage nodes, and
waits for f+1 to respond. Sufficient requests are sent in parallel to ensure low latency for
reads.</li>
<li>The reader authenticates the slivers returned with the blob ID, reconstructs the blob, and decides
whether the contents are a valid blob or inconsistent.</li>
<li>Optionally, for a cache, the result is cached and can be served without re-construction for some
time, until it is removed from the cache. Requests for the blob to the cache return the blob
contents, or a proof the blob is inconsistently encoded.</li>
</ul>
<h2 id="challenge-mechanism-for-storage-attestation"><a class="header" href="#challenge-mechanism-for-storage-attestation">Challenge mechanism for storage attestation</a></h2>
<p>During an epoch a correct storage node challenges all shards to provide blob slivers past PoA:</p>
<ul>
<li>The list of available blobs for the period is determined by the sequence of Sui events up
to the past period. Inconsistent blobs are not challenged, and a record proving this status
can be returned instead.</li>
<li>A challenge sequence is determined by providing a seed to the challenged shard. The sequence is
then computed based both on the seed AND the content of each challenged blob ID. This creates a
sequential read dependency.</li>
<li>The response to the challenge provides the sequence of shard contents for the blob IDs in a
timely manner.</li>
<li>The challenger node uses thresholds to determine whether the challenge was passed, and reports
the result on chain.</li>
<li>The challenge / response communication is authenticated.</li>
</ul>
<p>Challenges provide some reassurance that the storage node actually can recover shard data in a
probabilistic manner, avoiding storage nodes getting payment without any evidence they may retrieve
shard data. The sequential nature of the challenge and some reasonable timeout also ensure that
the process is timely.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-discussion"><a class="header" href="#future-discussion">Future discussion</a></h1>
<p>In this document, we left out details of the following features:</p>
<ul>
<li>Shard transfer and recovery upon storage epoch change. The encoding scheme used has been designed
to allow this operation to be efficient. A storage node needs to only get data of the same
magnitude to the missing sliver data to reconstruct them.</li>
<li>Details of light clients that can be used to sample availability. Individual clients may sample
the certified blobs from Sui metadata, and sample the availability of some slivers that they
store. On-chain bounties may be used to retrieve these slivers for missing blobs.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-walrus"><a class="header" href="#interacting-with-walrus">Interacting with Walrus</a></h1>
<p>We provide 3 ways to interact directly with the Walrus storage system:</p>
<ul>
<li>Through the walrus <a href="client-cli.html">client command line interface (CLI)</a>.</li>
<li>Through a <a href="json-api.html">JSON API</a> of the walrus CLI.</li>
<li>Through an <a href="web-api.html">HTTP API</a> exposed by the walrus client daemon.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-walrus-client"><a class="header" href="#using-the-walrus-client">Using the Walrus client</a></h1>
<p>The <code>walrus</code> binary can be used to interact with Walrus as a client. To use it, you need a Walrus
configuration and a Sui wallet.
Detailed usage information is available through</p>
<pre><code class="language-sh">cargo run --bin walrus -- --help
</code></pre>
<p>Storing and reading blobs from Walrus can be achieved through the following commands:</p>
<pre><code class="language-sh">CONFIG=working_dir/client_config.yaml # adjust for your configuration file
cargo run --bin walrus -- -c $CONFIG store &lt;some file&gt; # store a file
cargo run --bin walrus -- -c $CONFIG read &lt;some blob ID&gt; # read a blob
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-mode"><a class="header" href="#json-mode">JSON mode</a></h1>
<p>All Walrus client commands (except, currently, the <code>info</code> command) are available in JSON mode.
In this mode, all the command line flags of the original CLI command can be specified in JSON format.
The JSON mode therefore simplifies programmatic access to the CLI.</p>
<p>For example, to store a blob, run:</p>
<pre><code class="language-sh">cargo run --bin walrus -- json \
    '{
        "config": "working_dir/client_config.yaml",
        "command": {
            "store": {
                "file": "README.md"
            }
        }
    }'
</code></pre>
<p>or, to read a blob knowing the blob ID:</p>
<pre><code class="language-sh">cargo run --bin walrus -- json \
    '{
        "config": "working_dir/client_config.yaml",
        "command": {
            "read": {
                "blob_id": "4BKcDC0Ih5RJ8R0tFMz3MZVNZV8b2goT6_JiEEwNHQo"
            }
        }
    }'
</code></pre>
<p>The <code>json</code> command also accepts input from <code>stdin</code>.</p>
<p>The output of a <code>json</code> command will itself be JSON-formatted, again to simplify parsing the results
in a programmatic way. For example, the JSON output can be piped to the <code>jq</code> command for parsing and
manually extracting relevant fields.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-daemon-mode--http-api"><a class="header" href="#client-daemon-mode--http-api">Client Daemon mode &amp; HTTP API</a></h1>
<p>In addition to the CLI mode, the Walrus client offers a <em>daemon mode</em>. In this mode, it runs a
simple web server offering HTTP interfaces to store and read blobs.</p>
<h2 id="starting-the-daemon"><a class="header" href="#starting-the-daemon">Starting the daemon</a></h2>
<p>You can run the daemon with
different sets of API endpoints through one of the following commands:</p>
<pre><code class="language-sh">ADDRESS="127.0.0.1:31415" # bind the daemon to localhost and port 31415
cargo run --bin walrus -- -c $CONFIG aggregator -b $ADDRESS # run an aggregator to read blobs
cargo run --bin walrus -- -c $CONFIG publisher -b $ADDRESS # run a publisher to store blobs
cargo run --bin walrus -- -c $CONFIG daemon -b $ADDRESS # run a daemon combining an aggregator and a publisher
</code></pre>
<p>The aggregator provides all read APIs, the publisher all the store APIs, and daemon provides both.
Note that the aggregator does not perform Sui on-chain actions, and therefore consumes no gas.
However, the publisher does perform actions on-chain and will consume gas. It is therefore important
to ensure only authorized parties may access it, or other measures to manage gas costs.</p>
<h2 id="http-api-usage"><a class="header" href="#http-api-usage">HTTP API Usage</a></h2>
<p>You can then interact with the daemon through simple HTTP requests. For example, with
<a href="https://curl.se">cURL</a>, you can store blobs as follows:</p>
<pre><code class="language-sh">curl -X PUT "http://$ADDRESS/v1/store" -d "some string" # store the string `some string` for 1 storage epoch
curl -X PUT "http://$ADDRESS/v1/store?epochs=5" -d @"some/file" # store file `some/file` for 5 storage epochs
</code></pre>
<p>Blobs may be read using the following cURL command:</p>
<pre><code class="language-sh">curl "http://$ADDRESS/v1/&lt;some blob ID&gt;" # read a blob from Walrus (with aggregator or daemon)
</code></pre>
<p>Modern browsers will attempt to sniff the content type for such resources, and will generally do a
good job of inferring content types for media. However, the aggregator on purpose prevents such
sniffing from inferring dangerous executable types such as javascript or style sheet types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="walrus-glossary"><a class="header" href="#walrus-glossary">Walrus Glossary</a></h1>
<p>To make communication as clear and efficient as possible, we make sure to use a single term for
every Walrus entity/concept and <em>do not</em> use any synonyms. The following table lists various
concepts, their canonical name, how they relate to / differ from other terms.</p>
<p>Italicized terms in the description indicate other specific Walrus terms contained in the table.</p>
<div class="table-wrapper"><table><thead><tr><th>Approved name</th><th>Description</th></tr></thead><tbody>
<tr><td>storage node (SN)</td><td>entity storing data for Walrus; holds one or several <em>shards</em></td></tr>
<tr><td>blob</td><td>single unstructured data object stored on Walrus</td></tr>
<tr><td>shard</td><td>(disjoint) subset of erasure-encoded data of all <em>blobs</em>; at every point in time, a <em>shard</em> is assigned to and stored on a single <em>SN</em></td></tr>
<tr><td>sliver</td><td>erasure-encoded data of one <em>shard</em> corresponding to a single blob for one of the two encodings; this contains several erasure-encoded symbols of that blob but not the <em>blob metadata</em></td></tr>
<tr><td>blob ID</td><td>cryptographic ID computed from a <em>blob</em>’s <em>slivers</em></td></tr>
<tr><td>blob metadata</td><td>metadata of one <em>blob</em>; in particular, this contains a hash per <em>shard</em> to enable the authentication of <em>slivers</em> and recovery symbols</td></tr>
<tr><td>(end) user</td><td>any entity/person that wants to store or read <em>blobs</em> on/from Walrus; can act as a Walrus client itself or use the simple interface exposed by <em>publishers</em> and <em>caches</em></td></tr>
<tr><td>publisher</td><td>service interacting with Sui and the <em>SNs</em> to store <em>blobs</em> on Walrus; offers a simple HTTP POST endpoint to <em>end users</em></td></tr>
<tr><td>aggregator</td><td>service that reconstructs <em>blobs</em> by interacting with <em>SNs</em> and exposes a simple HTTP GET endpoint to <em>end users</em></td></tr>
<tr><td>cache</td><td>an <em>aggregator</em> with additional caching capabilities</td></tr>
<tr><td>(Walrus) client</td><td>entity interacting directly with the <em>SNs</em>; this can be an <em>aggregator</em>/<em>cache</em>, a <em>publisher</em>, or an <em>end user</em></td></tr>
<tr><td>(blob) reconstruction</td><td>decoding of the primary <em>slivers</em> to obtain the blob; includes re-encoding the <em>blob</em> and checking the Merkle proofs</td></tr>
<tr><td>(shard/sliver) recovery</td><td>process of an SN recovering a <em>sliver</em> or full <em>shard</em> by obtaining recovery symbols from other <em>SNs</em></td></tr>
<tr><td>storage attestation</td><td>process where <em>SNs</em> exchange challenges and responses to demonstrate that they are storing their currently assigned <em>shards</em></td></tr>
<tr><td>certificate of availability (CoA)</td><td>a <em>blob ID</em> with signatures of <em>SNs</em> holding at least $2f+1$ <em>shards</em> in a specific <em>epoch</em></td></tr>
<tr><td>point of availability (PoA)</td><td>point in time when a <em>CoA</em> is submitted to Sui and the corresponding <em>blob</em> is guaranteed to be available until its expiration</td></tr>
<tr><td>inconsistency proof</td><td>set of several recovery symbols with their Merkle proofs such that the decoded <em>sliver</em> does not match the corresponding hash; this proves an incorrect/inconsistent encoding by the client</td></tr>
<tr><td>inconsistency certificate</td><td>an aggregated signature from 2/3 of <em>SNs</em> (weighted by their number of <em>shards</em>) that they have seen and stored an <em>inconsistency proof</em> for a <em>blob ID</em></td></tr>
<tr><td>storage committee</td><td>the set of <em>SNs</em> for a <em>storage epoch</em>, including metadata about the <em>shards</em> they are responsible for and other metadata</td></tr>
<tr><td>member</td><td>an <em>SN</em> that is part of a <em>committee</em> at some <em>epoch</em></td></tr>
<tr><td>storage epoch</td><td>the epoch for Walrus as distinct to the epoch for Sui</td></tr>
<tr><td>availability period</td><td>the period specified in <em>storage epochs</em> for which a <em>blob</em> is certified to be available on Walrus</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
